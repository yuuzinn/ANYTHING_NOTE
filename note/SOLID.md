### SOLID ?

OOP SOLID의 원칙에 대해서 많이 들어봤다. 한 두어번 정도? 그런데 대강 알기만 하고 해서
이번 기회에 다시 잡아볼 겸 조금 정리해보도록 해야겠다. 영어는 그냥..뭐 읽지도, 기억도 못하는데 패스

### S - 단일 책임 원칙
- 객체는 단 하나의 책임만을 가져야 한다.
- 어떤 변화에 의해 클래스를 변경해야하는 이유는 오직 하나뿐이어야만 한다.

### O - 개방 폐쇄 원칙
- 기존 코드를 변경하지 않고 기능을 추가하도록 설계하여야 한다.
- 변화에는 닫혀 있으며 확장에는 열려 있다.

### L - 리스코프 치환 원칙
- 서브 클래스는 최소한 자신의 슈퍼 클래스에서 가능한 행위는 수행할 수 있어야 한다.

### I - 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여러 개가 여러방면으로 쓰이는 인터페이스 하나보다 낫다.
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

### D - 의존관계 역전 원칙
- 의존관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것.
  - 거의 변화가 없는 것에 의존해야만 한다.
- 구현 클래스에 의존하지 않고, 인터페이스에 의존하는 것이 좋다.

솔직히 SOLID를 다 지키면서 코딩하라고 하면 될까? 불가능해 보인다. 프로젝트 두 세번 경험해본 결과...
하다보면 의존성들이 많이 높아지는 것 같았다. 코드도 되게 복잡했고, 단일 책임 원칙만 해도 지키기 쉽지 않았다.

그런데 인터페이스 분리 원칙의 경우는 많이 사용했었던 것 같다. 아무래도 인터페이스를 그 행위에 맞게 시그니처를 설정하고
빈 껍데기들을 그에 맞게끔 나누어서 사용했으니.. 이건 나름 지켰을지도??

궁금한 것은 마지막 단에 _구현 클래스에 의존하지 않고, 인터페이스에 의존하는 것이 더 좋다는 말이 잘 모르겠다._
구현 클래스에 의존하게 되면 해당 클래스의 코드를 바꾸게 될 때 의존하고 있던 클래스의 코드도 변경해야해서 그런 것일까? 의문이다.

-> 의문점을 해결해줄 [글](https://dev-coco.tistory.com/180)을 찾게 되었는데, 개방 폐쇄 원칙과 의존관계 역전 원칙을 기반한 전략패턴 때문이란다.

그 `전략패턴`은 객체가 할 수 있는 행위들 각각 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로
행위의 수정이 가능하도록 만든 패턴이다.

그래서 보통 @Controller의 컨트롤러는 Service를 의존하는데, 여기에서 Service의 메서드를 이용해 어떠한 동작을 수행한다.
`컨트롤러의 입장에선 서비스 클래스의 비즈니스 로직에 대해선 관심이 없다.` 그냥 인터페이스의 빈 껍데기 메서드를 이용해 로직을 구성하기 때문이다.
따라서 Service 내부적으로 변경되든 영향을 받지 않음.(폐쇄)

그리고 Service는 인터페이스에서 규정된 규칙만 지키면 언제든 로직 변경이 가능하며, 인터페이스를 구현한 새로운 클래스를 하나 만들어서 기존 클래스를 대체도 가능케 한다.(확장)


**그리고 인터페이스는 컴파일 시점에 어떤 클래스를 담을지 결정하지 않으며 런타임 시점에 스프링 컨테이너에 존재하는 인터페이스 구현체 빈 중 하나를 주입받는다.**

`구현체가 런타임 시점에 지정되므로 컨트롤러는 실제 구현 클래스가 누군지 런타임 시점까지 알지 못한다. 컨트롤러와 서비스는 이로서 느슨한 관계를 지니게 된다.`

하지만 뭐... 본론의 내용과 다르지만 내 생각에는 이러한 장점들도 있고 하니 인터페이스를 만들어서 사용하긴 하지만.. 
근데 굳이 서비스 클래스(구현 클래스) - 1 인터페이스 - 1 이런 식으로 만들어 나가는 거는 의미도 없고.. 굳이? 싶다.