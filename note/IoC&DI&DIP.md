~~진짜 이 개념이 너무 나를 미치게 하는 거 같아~~ 이참에 정리하고자 한다.

헷갈리기도 하고, 이게 내가 IoC를 말하는 것인지 DIP를 말하는 것인지 너무나도 혼동이 된다.
스스로도 많이 답답함을 느끼고, 다른 개발자 분들과의 정확한 정보 전달을 위해선 꼭 정리해야지 싶다.

### IoC (Inversion of Controller)

코드(Software)의 흐름을 제어하는 주체가 바뀐다.

제어한다는 것은 여러 가지를 포함한다. 예를 들어 Object를 생성한다던지? 
Object의 생명주기를 관리한다던가? 메서드를 수행시킨다던지... 기본적으로는 
개발자(내)가 만들어놓은 코드는 스스로 실행된다. 누군가 대신해서 해주지 않는다.

IoC를 적용하는 것은 마지막 말처럼 흐름 제어를 나 말고 다른 이가 대신해서 해주는 것이다. 뭐 마치 주객전도 같기도 하다.

IoC의 대표적인 예시로 프레임워크인 Spring에서 나온다. 이에 대해서도 라이브러리 vs 프레임워크 구도가 많이 나오는데,
프레임워크는 우리가 작성해 놓은 코드를 자기들이 알아서 Bean을 생성하고, 생명주기도 관리하고(Bean Factory(Container)), 의존관계 마저 주입한다.
그리고 개발자가 변경할 수 없다. Spring을 어떻게 변경하는가? 

### DIP (Dependency Inversion principle, 의존관계 역전 법칙)

SOLID 원칙 중 마지막 원칙이다. DIP의 핵심은 바로 **추상화에 의존하라**는 것이다.

A라는 클래스가 B라는 구체 클래스에게 의존하고 있을 때의 문제점은 무엇일까?

결합도는 굉장히 높을 것이며, B라는 클래스가 변경된다면, A의 클래스도 변경되어야만 한다.
이의 구조는 변경에 유연하지 않다는 점이 핵심이다.

하지만 이제 추상화를 의존한다고 했을 때 (A라는 클래스가 B라는 Interface 를 의존할 경우)는 어떠한가?
인터페이스에 의존할 경우, 그를 구현하고 있는 구현체 클래스가 변경되어도 A 클래스는 변경의 영향을 받지 않는다. 
그리고 인터페이스를 구현한 구현체라면 무엇이든 A 클래스에서도 이용이 가능하다는 점이다. 
이는 다형성에도 관계가 있다. 따라서 변경에도 유연하다는 장점을 가지고 있다.

### DI (Dependency Injection, 의존성 주입)

필요한 Object를 스스로 생성하는 것이 아닌 외부로부터 주입받는 방식을 의미한다.
이의 방식으로는 3가지가 있다.

- 생성자 주입 방식
  - 인스턴스가 생성되고, 의존성이 존재하는 것이 보장되기 때문에 의존성의 존재 여부가 보장된다.
- Setter 주입 방식
  - 변경의 리스크가 있다. 생성자 주입 방식에 비해 더 주의를 해야한다. 주입 받는 의존성의 기본값이 정해져 있지 않는 경우
  null이 return 가능성이 있음.
- 필드 주입 방식
  - 외부에서 변경이 불가능해 test 하기에는 어려움이 있다.

---

가장 핵심은, 이 개념의 본질을 깨닫는 게 중요한 것 같다. 의도를 이해하고, 파악하는 것이 가장 우선이다.
근데 그게 안 되면 일단 외우기라도 하는 게..